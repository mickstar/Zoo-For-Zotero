package com.mickstarify.zooforzotero.ZoteroStorage.Database

import android.os.Parcelable
import androidx.room.ColumnInfo
import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import io.reactivex.rxjava3.core.Completable
import io.reactivex.rxjava3.core.Maybe
import io.reactivex.rxjava3.core.Single
import kotlinx.android.parcel.Parcelize


/*
* We are going to have a attachments table that will store metadata related to attachments.
* whenever an attachment is downloaded from
* */
@Entity(
    tableName = "AttachmentInfo", primaryKeys = ["itemKey", "group"],
    foreignKeys = [androidx.room.ForeignKey(
        entity = ItemInfo::class,
        parentColumns = ["itemKey"],
        childColumns = ["itemKey"],
        onDelete = ForeignKey.CASCADE
    )]
)
@Parcelize
class AttachmentInfo(
    @ColumnInfo(name = "itemKey") val itemKey: String,
    @ColumnInfo(name = "group") val groupParent: Int = Collection.NO_GROUP_ID,
    @ColumnInfo(name = "md5Key") val md5Key: String = "",
    @ColumnInfo(name = "mtime") val mtime: Long,
    @ColumnInfo(name = "downloadedFrom") val downloadedFrom: String = UNSET
) : Parcelable {
    companion object {
        const val UNSET = "UNSET"
        const val WEBDAV = "WEBDAV"
        const val ZOTEROAPI = "ZOTERO_API"
        // refers to metadata generated by the app scanning the directory
        const val LOCALSYNC = "LOCAL_SYNC"
    }
}

@Dao
interface AttachmentInfoDao {
    @Query("SELECT * FROM AttachmentInfo")
    fun getAll(): Maybe<List<AttachmentInfo>>

    @Query("SELECT * FROM AttachmentInfo WHERE `itemKey`=:key LIMIT 1")
    fun getAttachment(key: String): Single<AttachmentInfo>

    @Query("SELECT * FROM AttachmentInfo WHERE `group`=:groupID")
    fun getAttachmentsForGroup(groupID: Int): Maybe<List<AttachmentInfo>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertAttachments(attachments: List<AttachmentInfo>): Completable

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun updateAttachment(attachment: AttachmentInfo): Completable

    @Delete
    fun delete(attachmentInfo: AttachmentInfo): Completable
}